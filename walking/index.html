<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Platform Game</title>
    <style>
        /* --- Basic Setup --- */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
        }
        body {
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            color: white;
        }

        /* --- Main App Wrapper --- */
        #app-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        /* --- Game Container & Canvas --- */
        #game-container {
            border: 4px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px #fff;
            /* Set a fixed size for the container in windowed mode */
            width: 808px; /* GAME_WIDTH + 2 * border */
            height: 608px; /* GAME_HEIGHT + 2 * border */
        }
        canvas {
            display: block;
            background-color: #5c94fc; /* Sky blue background */
            /* Add this for crisp pixel art scaling */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* --- UI Elements --- */
        #info {
            margin-top: 15px;
            font-size: 16px;
            text-align: center;
        }
        #controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .game-button { /* A shared class for buttons */
            padding: 10px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            color: #000;
            background-color: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #999;
        }
        .game-button:active {
            box-shadow: 0 2px #666;
            transform: translateY(2px);
        }
        #restart-button {
            display: none; /* Hidden by default */
        }

        /* --- Fullscreen Styles --- */
        #app-wrapper:fullscreen {
            background-color: #000;
        }
        #app-wrapper:fullscreen #game-container {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #app-wrapper:fullscreen canvas {
            width: 100%;
            height: 100%;
            /* This is the key: scales the game while maintaining aspect ratio */
            object-fit: contain;
        }
        #app-wrapper:fullscreen #info,
        #app-wrapper:fullscreen #controls {
            /* Hide UI controls when in fullscreen */
            display: none;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>

    <div id="app-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="info">Use Arrow Keys/WASD to move and Space to Jump. Stomp on enemies!</div>
        <div id="controls">
            <button id="restart-button" class="game-button">Restart Game</button>
            <button id="fullscreen-button" class="game-button">Fullscreen</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restart-button');
        
        // NEW: Get references to the new elements
        const fullscreenButton = document.getElementById('fullscreen-button');
        const appWrapper = document.getElementById('app-wrapper');

        // --- Game Configuration ---
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        const GRAVITY = 0.6;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -15;
        const ENEMY_SPEED = 1.5;

        // --- Game State Variables ---
        let player, platforms, coins, enemies, camera;
        let score, lives, gameOver;
        
        // --- Procedural Generation Variables ---
        let generatedUntilX;
        let lastPlatform;

        // --- Player Object ---
        const initialPlayerState = {
            x: 100,
            y: 400,
            width: 40,
            height: 60,
            dx: 0,
            dy: 0,
            isJumping: false,
            direction: 'right',
            animationFrame: 0,
            frameCounter: 0
        };

        // --- Camera Object ---
        const cameraState = { x: 0, y: 0 };
        
        // --- Initialization ---
        function init() {
            player = { ...initialPlayerState };
            camera = { ...cameraState };
            
            score = 0;
            lives = 3;
            gameOver = false;
            restartButton.style.display = 'none';

            // Start with a single ground platform
            platforms = [
                { x: 0, y: 550, width: GAME_WIDTH + 200, height: 50 }
            ];
            lastPlatform = platforms[0];
            
            coins = [];
            enemies = [
                // Add one enemy at the start
                { x: 500, y: 510, width: 40, height: 40, dx: -ENEMY_SPEED, active: true, color: '#d63447' }
            ];

            generatedUntilX = lastPlatform.x + lastPlatform.width;
        }
        
        // NEW: Function to toggle fullscreen mode
        function toggleFullScreen() {
          if (!document.fullscreenElement) {
            // Request fullscreen on the app wrapper
            appWrapper.requestFullscreen().catch(err => {
              alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
          } else {
            document.exitFullscreen();
          }
        }

        // --- Input Handling ---
        const keys = { right: false, left: false };
        function keyDownHandler(e) {
            if (gameOver) return;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && !player.isJumping) {
                player.isJumping = true;
                player.dy = JUMP_FORCE;
            }
        }
        function keyUpHandler(e) {
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
        }

        // --- Procedural Generation ---
        function generateWorld() {
            // Generate new chunks of the world when player gets close to the edge
            while (generatedUntilX < player.x + GAME_WIDTH * 2) {
                const gap = 100 + Math.random() * 150; // Gap between platforms
                const width = 150 + Math.random() * 250; // Width of the new platform
                const heightChange = (Math.random() * 200) - 100; // How much higher/lower
                
                let y = lastPlatform.y + heightChange;
                // Clamp platform height to be reachable
                y = Math.max(200, Math.min(y, 550));

                const newPlatform = {
                    x: lastPlatform.x + lastPlatform.width + gap,
                    y: y,
                    width: width,
                    height: 20
                };
                platforms.push(newPlatform);

                // Add coins on the new platform
                if (Math.random() > 0.3) { // 70% chance of coins
                    for (let i = 0; i < width / 50; i++) {
                        coins.push({
                            x: newPlatform.x + (i * 50) + 15,
                            y: newPlatform.y - 40,
                            width: 20, height: 20, active: true
                        });
                    }
                }

                // Add an enemy on the new platform
                const enemyChance = 0.1 + (score / 5000); // Chance increases with score
                if (Math.random() < enemyChance && width > 100) { // Only on wider platforms
                    enemies.push({
                        x: newPlatform.x + width / 2,
                        y: newPlatform.y - 40,
                        width: 40, height: 40,
                        dx: -ENEMY_SPEED, active: true, color: '#d63447'
                    });
                }
                
                lastPlatform = newPlatform;
                generatedUntilX = newPlatform.x + newPlatform.width;
            }
        }

        function cleanupOldObjects() {
            // Remove objects that are far off-screen to the left to save memory
            const cleanupMargin = 400;
            platforms = platforms.filter(p => p.x + p.width > camera.x - cleanupMargin);
            coins = coins.filter(c => c.x + c.width > camera.x - cleanupMargin);
            enemies = enemies.filter(e => e.x + e.width > camera.x - cleanupMargin);
        }

        // --- Update Functions ---
        function update() {
            if (gameOver) return;

            updatePlayer();
            updateEnemies();
            checkCollisions();
            updateCamera();
            generateWorld();
            cleanupOldObjects();
        }

        function updatePlayer() {
            // Horizontal movement
            if (keys.right) {
                player.dx = PLAYER_SPEED;
                player.direction = 'right';
            } else if (keys.left) {
                player.dx = -PLAYER_SPEED;
                player.direction = 'left';
            } else {
                player.dx = 0;
            }
            player.x += player.dx;

            // Animation frame update for walking
            if (player.dx !== 0 && !player.isJumping) {
                player.frameCounter++;
                if (player.frameCounter > 4) { // Adjust for animation speed
                    player.animationFrame = (player.animationFrame + 1) % 4; // 4 frames for walk cycle
                    player.frameCounter = 0;
                }
            } else if (player.dx === 0) {
                player.animationFrame = 0; // Reset to idle frame when still
            }

            // Apply gravity
            player.dy += GRAVITY;
            player.y += player.dy;
            
            if (player.x < 0) player.x = 0;

            if (player.y > GAME_HEIGHT) {
                playerLosesLife();
            }
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                if (!enemy.active) return;
                enemy.x += enemy.dx;

                // Simple patrol AI: turn around at platform edges
                let onAPlatform = false;
                let currentPlatform;
                for(const p of platforms) {
                    if (enemy.y + enemy.height === p.y && enemy.x > p.x && enemy.x + enemy.width < p.x + p.width) {
                        onAPlatform = true;
                        currentPlatform = p;
                        break;
                    }
                }
                if (onAPlatform) {
                    if(enemy.x < currentPlatform.x || enemy.x + enemy.width > currentPlatform.x + currentPlatform.width) {
                       enemy.dx *= -1;
                    }
                } else {
                    // If not on a platform (e.g., spawned in the air), just move
                    // A more complex game would have them fall with gravity
                }
            });
        }
        
        function updateCamera() {
            camera.x = player.x - (GAME_WIDTH / 2.5);
            if (camera.x < 0) camera.x = 0;
        }

        // --- Collision Detection ---
        function checkCollisions() {
            // Platform collisions
            let onPlatform = false;
            platforms.forEach(platform => {
                if (player.dy > 0 && isColliding(player, platform) && (player.y + player.height) < platform.y + player.dy + 1) {
                    player.isJumping = false;
                    player.y = platform.y - player.height;
                    player.dy = 0;
                    onPlatform = true;
                }
            });

            // Coin collisions
            coins.forEach(coin => {
                if (coin.active && isColliding(player, coin)) {
                    coin.active = false;
                    score += 10;
                }
            });

            // Enemy collisions
            enemies.forEach(enemy => {
                if (!enemy.active) return;
                if (isColliding(player, enemy)) {
                    if (player.dy > 0 && player.y + player.height < enemy.y + player.dy + 20) {
                        enemy.active = false;
                        player.dy = -8; // small bounce
                        score += 50;
                    } else { 
                        playerLosesLife();
                    }
                }
            });
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // --- Game State Management ---
        function playerLosesLife() {
            if (gameOver) return;
            lives--;
            if (lives <= 0) {
                gameOver = true;
                restartButton.style.display = 'block';
            } else {
                player.x = camera.x + 100;
                player.y = 100;
                player.dy = 0;
            }
        }

        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            drawBackground();
            drawPlatforms();
            drawCoins();
            drawEnemies();
            drawPlayer();
            
            ctx.restore();
            
            drawUI();

            if (gameOver) {
                drawGameOver();
            }
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height);

            if (player.direction === 'left') {
                ctx.scale(-1, 1);
            }

            const skin = '#f0c0a0';
            const hair = '#6a341a';
            const shirt = '#e62e2e';
            const overalls = '#3a86ff';
            const shoes = '#784421';
            const gloves = '#ffffff';

            let legOffset = 0;
            let armAngle = 0;

            if (player.isJumping) {
                legOffset = -5;
                armAngle = -Math.PI / 4;
            } else if (player.dx !== 0) {
                const walkCycle = [0, 5, 0, -5];
                legOffset = walkCycle[player.animationFrame];
                armAngle = (walkCycle[player.animationFrame] / 10) * (Math.PI / 8);
            }

            ctx.fillStyle = overalls;
            ctx.fillRect(-15, -25 + (legOffset > 0 ? legOffset / 2 : 0), 10, 20);
            ctx.fillStyle = shoes;
            ctx.fillRect(-18, -5, 16, 5);
            ctx.fillStyle = overalls;
            ctx.fillRect(5, -25 - (legOffset < 0 ? legOffset / 2 : 0), 10, 20);
            ctx.fillStyle = shoes;
            ctx.fillRect(2, -5, 16, 5);
            ctx.fillStyle = shirt;
            ctx.fillRect(-15, -55, 30, 30);
            ctx.fillStyle = overalls;
            ctx.fillRect(-15, -45, 30, 20);
            ctx.fillRect(-20, -45, 5, 15);
            ctx.fillRect(15, -45, 5, 15);
            ctx.fillStyle = skin;
            ctx.fillRect(-12, -75, 24, 20);
            ctx.fillStyle = hair;
            ctx.fillRect(-15, -78, 30, 5);
            ctx.fillRect(-15, -75, 5, 5);
            ctx.fillStyle = shirt;
            ctx.fillRect(-18, -85, 36, 10);
            ctx.fillRect(-22, -75, 44, 5);

            ctx.save();
            ctx.translate(0, -50);
            ctx.rotate(armAngle);
            ctx.fillStyle = shirt;
            ctx.fillRect(0, 0, 10, 20);
            ctx.fillStyle = gloves;
            ctx.beginPath();
            ctx.arc(5, 20, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.restore();
        }

        function drawPlatforms() {
            platforms.forEach(platform => {
                ctx.fillStyle = '#228B22';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height + (platform.y < 550 ? 20 : 0));
            });
        }

        function drawCoins() {
            ctx.fillStyle = '#f1c40f';
            coins.forEach(coin => {
                if(coin.active) {
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width / 2, coin.y + coin.height / 2, coin.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                if (enemy.active) {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
            });
        }

        function drawBackground() {
            const cloudWidth = 400;
            const startCloud = Math.floor(camera.x / cloudWidth);
            const endCloud = Math.ceil((camera.x + GAME_WIDTH) / cloudWidth);

            ctx.fillStyle = 'white';
            for (let i = startCloud; i <= endCloud; i++) {
                 ctx.beginPath();
                 ctx.arc(100 + i * cloudWidth, 100, 40, 0, Math.PI * 2);
                 ctx.arc(150 + i * cloudWidth, 100, 50, 0, Math.PI * 2);
                 ctx.arc(200 + i * cloudWidth, 100, 40, 0, Math.PI * 2);
                 ctx.fill();
            }
        }
        
        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '24px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 20, 40);
            ctx.textAlign = 'right';
            ctx.fillText(`Lives: ${lives}`, GAME_WIDTH - 20, 40);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = 'white';
            ctx.font = '48px "Press Start 2P"';
            ctx.textAlign = 'center';

            ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2);
            ctx.font = '24px "Press Start 2P"';
            ctx.fillText(`Final Score: ${score}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60);

            restartButton.style.display = 'block';
        }

        // --- Game Loop ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        restartButton.addEventListener('click', () => {
            init();
        });
        
        // NEW: Add event listener for the fullscreen button
        fullscreenButton.addEventListener('click', toggleFullScreen);

        // --- Start Game ---
        window.onload = function() {
            init();
            gameLoop();
        };
    </script>
</body>
</html>